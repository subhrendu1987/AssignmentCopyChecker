// Client side C/C++ program to demonstrate Socket programming
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>

const char *server_ip;
int port;

int login(int sock)
{
    char username[10] = {0}, password[100] = {0}, buffer[1024] = {0};
   
    printf("Login\n");
    printf("Username: ");
    scanf("%s", username);
    printf("Password: ");
    scanf("%s", password);

    strcat(username, " ");
    strcat(username, password);
    
    
    send(sock, username, strlen(username), 0);
    read(sock, buffer, 1024);
    
    printf("%s\n", buffer);
    
    if (!strcmp(buffer, "No")) {
        printf("Login Failed\n");
        return 0;
    }
    printf("Login Successfull\n");
    return 1;
}

void order_status(int sock)
{
    char buffer[1024] = {0};

    read(sock, buffer, 1024);
    // printf("\n\naaa%s\n\n", buffer);
    if (!strcmp(buffer, "end1"))
        printf("\nNo sell orders\n");
    else
        printf("\nSell orders\n===========\n");

    
    while(strcmp(buffer, "end1")) {
        // printf("\nHERE %s\n", buffer);   
        char *sid = strtok(buffer, " ");
        char *price = strtok(NULL, " ");
        char *quantity = strtok(NULL, " ");
        printf("Item Code %s \t\t Best Price %s \t\t Quantity %s\n", sid, price, quantity);
        memset(buffer, 0, 1024);
        read(sock, buffer, 1024);
        // printf("\n\nbbb%s\n\n", buffer);
    }
    memset(buffer, 0, 1024);
    read(sock, buffer, 1024);
    
    // printf("\n\nccc%s\n\n", buffer);
    
    if (!strcmp(buffer, "end2"))
        printf("\nNo buy orders\n");
    else
        printf("\nBuy orders\n============\n");

    while(strcmp(buffer, "end2")) {
        char *sid = strtok(buffer, " ");
        char *price = strtok(NULL, " ");
        char *quantity = strtok(NULL, " ");
        printf("Item Code %s \t\t Best Price %s \t\t Quantity %s\n", sid, price, quantity);
        memset(buffer, 0, 1024);
        read(sock, buffer, 1024);
    }

}

int trade_status(int sock)
{
    char buffer[1024] = {0};

    read(sock, buffer, 1024);
    while(strcmp(buffer, "end")) {
        char *a = strtok(buffer, " ");
        char *b = strtok(NULL, " ");
        char *c = strtok(NULL, " ");
        char *d = strtok(NULL, " ");
        char *e = strtok(NULL, " ");

        printf("%s \nItem Code - %s \t\t Price - %s \t\t Quantity - %s \t\t Counterparty_id - %s\n",
                    a, b, c, d, e);
        memset(buffer, 0, 1024);
        read(sock, buffer, 1024);
    }
}

int main(int argc, char const *argv[])
{
    struct sockaddr_in address;
    int sock = 0, valread;
    
    // Set the server's port and ip address
    port = atoi(argv[2]);
    server_ip = argv[1];

    struct sockaddr_in serv_addr;
    char buffer[1024] = {0};
    // char hello[1024];
    while(1) {
        if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)
        {
            printf("\n Socket creation error \n");
            return -1;
        }

        memset(&serv_addr, '0', sizeof(serv_addr));
      
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_port = htons(port);

        // Convert IPv4 and IPv6 addresses from text to binary form
        if(inet_pton(AF_INET, server_ip, &serv_addr.sin_addr)<=0) 
        {
            printf("\nInvalid address/ Address not supported \n");
            return -1;
        }

        if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
        {
            printf("\nNo server \n");
            return -1;
        }

        if (!login(sock))       //If login fails then reconnect with server
            continue;

        while(1) {
            char hello[1024] = {0};
            printf("Request: ");
            memset(hello, 0, sizeof(hello));           
            scanf("%s", hello);
            send(sock, hello, strlen(hello), 0);
            printf("Request sent\n");
            
            if(!strcmp(hello, "Order_Status"))
                order_status(sock);
            else if(!strcmp(hello, "Trade_Status"))
                trade_status(sock);

            memset(buffer, 0, sizeof(buffer));
            valread = read( sock , buffer, 1024);
            if (!valread) {
                printf("Connection lost\n");
                break;
            }
            if(strcmp(buffer, "done"))
                printf("%s\n", buffer);
        }
    }
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include "list.h"

// extern struct order* buy_orders[10] = {NULL};
// extern struct order* sell_orders[10] = {NULL};
// extern struct trade* trades;

/* Type 1 = Buy; Type 2 = Sell. */
void insert_order(int type, struct order *ord, struct order *buy_orders[10], struct order *sell_orders[10], 
                  struct trade *trades)
{
  // Index into the array for the required list.
  struct order *o, *head;
  if(type==1)
    o = buy_orders[ord->item_code];
  else
    o = sell_orders[ord->item_code];
  head = o;
  int flag = 0;
  if(o==NULL)
  {
    head = ord;
    flag = 1;
  }
  else
      while(o!=NULL && flag!=1)
      {  
        // Buy orders are sorted in decreasing order.
        if(type==1 && o->price < ord->price || type==2 && o->price>ord->price)
        {
            if(head==o)
            {
                ord->next = head;
                head->prev = ord;
                head = ord;
            }
            else
            {
                ord->prev = o->prev;
                ord->next = o;
                (o->prev)->next = ord;
                o->prev = ord;
            }
            flag = 1;
        }
        else
            o = o->next;
      }
  if(flag == 0)
    printf("Should not print ever\n");
  if(type==1)
    buy_orders[ord->item_code] = head;
  else
    sell_orders[ord->item_code] = head;
  execute(type, ord, buy_orders, sell_orders, trades);
}

void insert_trade(struct trade* tr, struct order *buy_orders[10], struct order *sell_orders[10], 
                  struct trade *trades)
{
    tr->next = trades;
    trades = tr;
}

void order_status(int new_socket, struct order *buy_orders[10], struct order *sell_orders[10], 
                  struct trade *trades)
{
    int i;
    char msg[1024] = {0}, temp[1024] = {0};
    memset(msg, 0, 1024);
    for(i=0;i<10;i++)
    {
      if(sell_orders[i]!=NULL) {
        sprintf(msg, "%d", i+1);
        sprintf(temp, "%d", sell_orders[i]->price);
        strcat(msg, " ");
        strcat(msg, temp);
        sprintf(temp, "%d", sell_orders[i]->quantity);
        strcat(msg, " ");
        strcat(msg, temp);
        sleep(1); send(new_socket, msg, strlen(msg) + 1, 0);
        printf("mehul %s\n", msg);
        printf("Item Code %d \t\t Best Price %d \t\t Quantity %d\n", i+1, sell_orders[i]->price,
            sell_orders[i]->quantity);
      }
      memset(msg, 0, 1024);
    }
    strcpy(msg, "end1\0");
    sleep(1); send(new_socket, msg, strlen(msg) + 1, 0);
        printf("mehul %s\n", msg);
    for(i=0;i<10;i++)
    {
        if(buy_orders[i]!=NULL) {
        sprintf(msg, "%d", i+1);
        sprintf(temp, "%d", buy_orders[i]->price);
        strcat(msg, " ");
        strcat(msg, temp);
        sprintf(temp, "%d", buy_orders[i]->quantity);
        strcat(msg, " ");
        strcat(msg, temp);
        sleep(1); send(new_socket, msg, strlen(msg) + 1, 0);
        printf("mehul %s\n", msg);
        printf("Item Code %d \t\t Best Price %d \t\t Quantity %d\n", i+1, buy_orders[i]->price,
            buy_orders[i]->quantity);
      }
      memset(msg, 0, 1024);
    }
    strcpy(msg, "end2\0");
    sleep(1); send(new_socket, msg, strlen(msg) + 1, 0);
        printf("mehul %s\n", msg);
}

void trade_status(int trader_id, int new_socket, struct order *buy_orders[10], struct order *sell_orders[10], 
                  struct trade *trades)
{
    struct trade* t = trades;

    char msg[1024] = {0}, temp[1024] = {0};
    while(t!=NULL)
    {
        if(t->seller == trader_id || t->buyer == trader_id)
        {
            int counterparty;
            if(t->seller==trader_id)
            {
                strcpy(msg, "Sell_Order");
                strcat(msg, " ");
                // printf("Sell Order\n");
                // counterparty = t->buyer;
            }
            else
            {
                strcpy(msg, "Buy_Order");
                strcat(msg, " ");
                // printf("Buy Order\n");
                counterparty = t->seller;
            }

            sprintf(temp, "%d", t->item_code);
            strcat(msg, temp);
            strcat(msg, " ");
            sprintf(temp, "%d", t->price);
            strcat(msg, temp);
            strcat(msg, " ");
            sprintf(temp, "%d", t->quantity);
            strcat(msg, temp);
            strcat(msg, " ");
            sprintf(temp, "%d", counterparty+1);
            strcat(msg, temp);
            sleep(1); 
            send(new_socket, msg, strlen(msg) + 1, 0);

            // printf("Item Code - %d \t\t Price - %d \t\t Quantity - %d \t\t Counterparty Code - %d\n",
                // t->item_code, t->price, t->quantity, counterparty);
        }
        t = t->next;
    }
    strcpy(msg, "end\0");
    sleep(1); 
    send(new_socket, msg, strlen(msg) + 1, 0);
}

void execute(int type, struct order *ord, struct order *buy_orders[10], struct order *sell_orders[10], 
                  struct trade *trades)
{
  // return;
  struct order* o;
    if (type == 1) {
      o = sell_orders[ord->item_code];
      while (o != NULL && ord->quantity > 0) {
        if (o->price <= ord->price && o->quantity > 0) {
          int m = (o->quantity < ord->quantity ? o->quantity : ord->quantity);
          printf("Trading sell %d\n", m);
          o->quantity = o->quantity - m;
          ord->quantity = ord->quantity - m;

          struct trade* tr = (struct trade*)mmap(NULL, sizeof(struct trade), PROT_READ | PROT_WRITE, 
                    MAP_SHARED | MAP_ANONYMOUS, -1, 0);
          tr->buyer = ord->trader_id;
          tr->seller = o->trader_id;
          tr->item_code = ord->item_code;
          tr->price = o->price;
          tr->quantity = m;
          insert_trade(tr, buy_orders, sell_orders, trades);
        }
        o=o->next;
      }
    } else {
      o = buy_orders[ord->item_code];
      while (o != NULL && ord->quantity > 0) {
        if (o->price >= ord->price && o->quantity > 0) {
          int m = (o->quantity < ord->quantity ? o->quantity : ord->quantity);
          o->quantity = o->quantity - m;
          printf("Trading sell %d\n", m);
          ord->quantity = ord->quantity - m;

          struct trade* tr = (struct trade*)mmap(NULL, sizeof(struct trade), PROT_READ | PROT_WRITE, 
                    MAP_SHARED | MAP_ANONYMOUS, -1, 0);
          tr->buyer = o->trader_id;
          tr->seller = ord->trader_id;
          tr->item_code = ord->item_code;
          tr->price = ord->price;
          tr->quantity = m;
          insert_trade(tr, buy_orders, sell_orders, trades);
        }
        o=o->next;
      }
    }
}#include <stdio.h>
#include <stdlib.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/mman.h>

/* Single order struct. */
struct order{
  int trader_id;
  int item_code;
  unsigned int price;
  unsigned int quantity;
  struct order* next;
  struct order* prev;
};

/* A trade is an executed order. */
struct trade{
  int buyer;
  int seller;
  int item_code;
  int price;
  int quantity;
  struct trade* next;
  // struct trade* prev;
};

/* Type 1 = Buy; Type 2 = Sell. */
void insert_order(int, struct order*, struct order *buy_orders[10], struct order *sell_orders[10], 
                  struct trade *trades);
void insert_trade(struct trade*, struct order *buy_orders[10], struct order *sell_orders[10], 
                  struct trade *trades);
void order_status(int, struct order *buy_orders[10], struct order *sell_orders[10], 
                  struct trade *trades);
void trade_status(int, int, struct order *buy_orders[10], struct order *sell_orders[10], 
                  struct trade *trades);
void execute(int, struct order*, struct order *buy_orders[10], struct order *sell_orders[10], 
                  struct trade *trades);// Server side C program to demonstrate Socket programming
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/mman.h>


#include "list.h"
struct order  **buy_orders;
struct order **sell_orders;
struct trade* trades;

int port, new_socket;
char *trader_pass[10] = {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10"};
char buffer[1024] = {0};

int login(int new_socket)
{
    char buffer[1024] = {0}, ack[1024] = {0};
    memset(buffer, 0, 1024);
    read(new_socket, buffer, 1024);

    char *username = strtok(buffer, " ");
    char *password = strtok(NULL, " ");

    int result = 0;
    if (strcmp(trader_pass[atoi(username)-1], password))
        strcpy(ack, "No\0");
    else {
        result = atoi(username);
        strcpy(ack, "Yes\0");
    }
    printf("Trader %s logged in\n", username);
    send(new_socket, ack, strlen(ack), 0);
    return result;
}

void process(char *command, int trader_id, int new_socket)
{
    if(!strcmp(buffer, "Buy\0") || !strcmp(buffer, "Sell\0"))
    {
        int id;
        if (!strcmp(buffer, "Buy\0"))
            id = 1;
        else
            id = 2;
        // struct order *t = malloc(sizeof(struct order));

       struct order *t = mmap(NULL, sizeof(struct order), PROT_READ | PROT_WRITE, 
                    MAP_SHARED | MAP_ANONYMOUS, -1, 0);

        t->trader_id = trader_id;
        char *str = "Item Code\0";
        send(new_socket , str , strlen(str) , 0 );
        memset(buffer, 0, 1024);
        read(new_socket, buffer, 1024);
        sscanf(buffer, "%d", &t->item_code);
        str = "Quantity\0";
        send(new_socket , str , strlen(str), 0 );
        memset(buffer, 0, 1024);
        read(new_socket, buffer, 1024);
        sscanf(buffer, "%d", &t->quantity);
        str = "Price\0";
        send(new_socket , str , strlen(str), 0 );
        memset(buffer, 0, 1024);
        read(new_socket, buffer, 1024);
        sscanf(buffer, "%d", &t->price);
        t->next = NULL;
        t->prev = NULL;
        t->item_code = t->item_code-1;
        printf("AD: %s\n\n", buffer);
        insert_order(id,t, buy_orders, sell_orders, trades);

        // Run matching routine.
        // execute(type);
    }

    else if(!strcmp(buffer, "Order_Status\0"))
        order_status(new_socket,buy_orders, sell_orders, trades);
    else if(!strcmp(buffer, "Trade_Status\0"))
        trade_status(trader_id, new_socket,buy_orders, sell_orders, trades);
    else
        printf("Wrong input: %s\n", buffer);
    char *str = "done\0";
    sleep(1);
    send(new_socket , str , strlen(str), 0 );

}

int main(int argc, char const *argv[])
{
    // buy_orders = (struct order**)malloc(sizeof(struct order*)*10);
    // sell_orders = (struct order**)malloc(sizeof(struct order*)*10);

    buy_orders = (struct order**)mmap(NULL, sizeof(struct order*)*10, PROT_READ | PROT_WRITE, 
                    MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    sell_orders = (struct order**)mmap(NULL, sizeof(struct order*)*10, PROT_READ | PROT_WRITE, 
                    MAP_SHARED | MAP_ANONYMOUS, -1, 0);

    // struct order *t = mmap(NULL, sizeof(struct order), PROT_READ | PROT_WRITE, 
    //                 MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    
    for (int i = 0; i < 10; i++) {
        buy_orders[i] = NULL;
        sell_orders[i] = NULL;
    }

    int server_fd, valread;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);
    char *hello = "Hello from server";
    
    // Set port for server
    port = atoi(argv[1]);

    // Creating socket file descriptor
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0)
    {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }
      
    // Forcefully attaching socket to the port 8080
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT,
                                                  &opt, sizeof(opt)))
    {
        perror("setsockopt");
        exit(EXIT_FAILURE);
    }
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(port);
      
    // Forcefully attaching socket to the port 8080
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address))<0)
    {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }
    
    /* Server goes in passive mode. Wakes up only when a connection
     * request is made
     */
    if (listen(server_fd, 10) < 0)
    {
        perror("listen");
        exit(EXIT_FAILURE);
    }

    /* Server continues to listen for new connections. */
    while(1) {
        if ((new_socket = accept(server_fd, (struct sockaddr *)&address,
                           (socklen_t*)&addrlen))<0)
        {
            perror("accept");
            exit(EXIT_FAILURE);
        }

        /*Create child process. It handles a single client.*/
        int pid = fork();
        if (pid == 0) {
            /* Child process will stop listening for new connection
             * but will maintain the connection with this client.
             */
            close(server_fd);

            int trader_id = login(new_socket);
            if(trader_id == 0)      //Exit the process if login fails
                    exit(0);

            while(1) {
                 memset(buffer, 0, 1024);
                valread = read(new_socket, buffer, 1024);
                printf("%s\n", buffer);
                process(buffer, trader_id, new_socket);
                // send(new_socket, hello, strlen(hello), 0);
            }    
            exit(0);
        }
        else
            close(new_socket); //Parent closes the connection with client.
    }
    return 0;
}
